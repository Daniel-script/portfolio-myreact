{"ast":null,"code":"import _toConsumableArray from \"C:/Users/ferre/OneDrive/Escritorio/portfolio-react/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport { color } from '../color/index.mjs';\nimport { number } from '../numbers/index.mjs';\nimport { isString, floatRegex, colorRegex, sanitize } from '../utils.mjs';\nvar colorToken = \"${c}\";\nvar numberToken = \"${n}\";\nfunction test(v) {\n  var _a, _b;\n  return isNaN(v) && isString(v) && (((_a = v.match(floatRegex)) === null || _a === void 0 ? void 0 : _a.length) || 0) + (((_b = v.match(colorRegex)) === null || _b === void 0 ? void 0 : _b.length) || 0) > 0;\n}\nfunction analyseComplexValue(v) {\n  if (typeof v === \"number\") v = \"\".concat(v);\n  var values = [];\n  var numColors = 0;\n  var numNumbers = 0;\n  var colors = v.match(colorRegex);\n  if (colors) {\n    numColors = colors.length;\n    // Strip colors from input so they're not picked up by number regex.\n    // There's a better way to combine these regex searches, but its beyond my regex skills\n    v = v.replace(colorRegex, colorToken);\n    values.push.apply(values, _toConsumableArray(colors.map(color.parse)));\n  }\n  var numbers = v.match(floatRegex);\n  if (numbers) {\n    numNumbers = numbers.length;\n    v = v.replace(floatRegex, numberToken);\n    values.push.apply(values, _toConsumableArray(numbers.map(number.parse)));\n  }\n  return {\n    values: values,\n    numColors: numColors,\n    numNumbers: numNumbers,\n    tokenised: v\n  };\n}\nfunction parse(v) {\n  return analyseComplexValue(v).values;\n}\nfunction createTransformer(source) {\n  var _analyseComplexValue = analyseComplexValue(source),\n    values = _analyseComplexValue.values,\n    numColors = _analyseComplexValue.numColors,\n    tokenised = _analyseComplexValue.tokenised;\n  var numValues = values.length;\n  return function (v) {\n    var output = tokenised;\n    for (var i = 0; i < numValues; i++) {\n      output = output.replace(i < numColors ? colorToken : numberToken, i < numColors ? color.transform(v[i]) : sanitize(v[i]));\n    }\n    return output;\n  };\n}\nvar convertNumbersToZero = function convertNumbersToZero(v) {\n  return typeof v === \"number\" ? 0 : v;\n};\nfunction getAnimatableNone(v) {\n  var parsed = parse(v);\n  var transformer = createTransformer(v);\n  return transformer(parsed.map(convertNumbersToZero));\n}\nvar complex = {\n  test: test,\n  parse: parse,\n  createTransformer: createTransformer,\n  getAnimatableNone: getAnimatableNone\n};\nexport { analyseComplexValue, complex };","map":{"version":3,"names":["color","number","isString","floatRegex","colorRegex","sanitize","colorToken","numberToken","test","v","_a","_b","isNaN","match","length","analyseComplexValue","concat","values","numColors","numNumbers","colors","replace","push","apply","_toConsumableArray","map","parse","numbers","tokenised","createTransformer","source","_analyseComplexValue","numValues","output","i","transform","convertNumbersToZero","getAnimatableNone","parsed","transformer","complex"],"sources":["C:/Users/ferre/OneDrive/Escritorio/portfolio-react/node_modules/framer-motion/dist/es/value/types/complex/index.mjs"],"sourcesContent":["import { color } from '../color/index.mjs';\nimport { number } from '../numbers/index.mjs';\nimport { isString, floatRegex, colorRegex, sanitize } from '../utils.mjs';\n\nconst colorToken = \"${c}\";\nconst numberToken = \"${n}\";\nfunction test(v) {\n    var _a, _b;\n    return (isNaN(v) &&\n        isString(v) &&\n        (((_a = v.match(floatRegex)) === null || _a === void 0 ? void 0 : _a.length) || 0) +\n            (((_b = v.match(colorRegex)) === null || _b === void 0 ? void 0 : _b.length) || 0) >\n            0);\n}\nfunction analyseComplexValue(v) {\n    if (typeof v === \"number\")\n        v = `${v}`;\n    const values = [];\n    let numColors = 0;\n    let numNumbers = 0;\n    const colors = v.match(colorRegex);\n    if (colors) {\n        numColors = colors.length;\n        // Strip colors from input so they're not picked up by number regex.\n        // There's a better way to combine these regex searches, but its beyond my regex skills\n        v = v.replace(colorRegex, colorToken);\n        values.push(...colors.map(color.parse));\n    }\n    const numbers = v.match(floatRegex);\n    if (numbers) {\n        numNumbers = numbers.length;\n        v = v.replace(floatRegex, numberToken);\n        values.push(...numbers.map(number.parse));\n    }\n    return { values, numColors, numNumbers, tokenised: v };\n}\nfunction parse(v) {\n    return analyseComplexValue(v).values;\n}\nfunction createTransformer(source) {\n    const { values, numColors, tokenised } = analyseComplexValue(source);\n    const numValues = values.length;\n    return (v) => {\n        let output = tokenised;\n        for (let i = 0; i < numValues; i++) {\n            output = output.replace(i < numColors ? colorToken : numberToken, i < numColors\n                ? color.transform(v[i])\n                : sanitize(v[i]));\n        }\n        return output;\n    };\n}\nconst convertNumbersToZero = (v) => typeof v === \"number\" ? 0 : v;\nfunction getAnimatableNone(v) {\n    const parsed = parse(v);\n    const transformer = createTransformer(v);\n    return transformer(parsed.map(convertNumbersToZero));\n}\nconst complex = { test, parse, createTransformer, getAnimatableNone };\n\nexport { analyseComplexValue, complex };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}