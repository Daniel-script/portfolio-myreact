{"ast":null,"code":"import _objectSpread from \"C:/Users/ferre/OneDrive/Escritorio/portfolio-react/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _objectWithoutProperties from \"C:/Users/ferre/OneDrive/Escritorio/portfolio-react/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nimport _slicedToArray from \"C:/Users/ferre/OneDrive/Escritorio/portfolio-react/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nvar _excluded = [\"transition\", \"transitionEnd\"];\nimport { setTarget } from './setters.mjs';\nimport { resolveVariant } from './resolve-dynamic-variants.mjs';\nimport { transformProps } from '../html/utils/transform.mjs';\nimport { isWillChangeMotionValue } from '../../value/use-will-change/is.mjs';\nimport { optimizedAppearDataAttribute } from '../../animation/optimized-appear/data-id.mjs';\nimport { createMotionValueAnimation } from '../../animation/index.mjs';\nimport { sync } from '../../frameloop/index.mjs';\nfunction animateVisualElement(visualElement, definition) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  visualElement.notify(\"AnimationStart\", definition);\n  var animation;\n  if (Array.isArray(definition)) {\n    var animations = definition.map(function (variant) {\n      return animateVariant(visualElement, variant, options);\n    });\n    animation = Promise.all(animations);\n  } else if (typeof definition === \"string\") {\n    animation = animateVariant(visualElement, definition, options);\n  } else {\n    var resolvedDefinition = typeof definition === \"function\" ? resolveVariant(visualElement, definition, options.custom) : definition;\n    animation = animateTarget(visualElement, resolvedDefinition, options);\n  }\n  return animation.then(function () {\n    return visualElement.notify(\"AnimationComplete\", definition);\n  });\n}\nfunction animateVariant(visualElement, variant) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var _a;\n  var resolved = resolveVariant(visualElement, variant, options.custom);\n  var _ref = resolved || {},\n    _ref$transition = _ref.transition,\n    transition = _ref$transition === void 0 ? visualElement.getDefaultTransition() || {} : _ref$transition;\n  if (options.transitionOverride) {\n    transition = options.transitionOverride;\n  }\n  /**\n   * If we have a variant, create a callback that runs it as an animation.\n   * Otherwise, we resolve a Promise immediately for a composable no-op.\n   */\n  var getAnimation = resolved ? function () {\n    return animateTarget(visualElement, resolved, options);\n  } : function () {\n    return Promise.resolve();\n  };\n  /**\n   * If we have children, create a callback that runs all their animations.\n   * Otherwise, we resolve a Promise immediately for a composable no-op.\n   */\n  var getChildAnimations = ((_a = visualElement.variantChildren) === null || _a === void 0 ? void 0 : _a.size) ? function () {\n    var forwardDelay = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    var _transition = transition,\n      _transition$delayChil = _transition.delayChildren,\n      delayChildren = _transition$delayChil === void 0 ? 0 : _transition$delayChil,\n      staggerChildren = _transition.staggerChildren,\n      staggerDirection = _transition.staggerDirection;\n    return animateChildren(visualElement, variant, delayChildren + forwardDelay, staggerChildren, staggerDirection, options);\n  } : function () {\n    return Promise.resolve();\n  };\n  /**\n   * If the transition explicitly defines a \"when\" option, we need to resolve either\n   * this animation or all children animations before playing the other.\n   */\n  var _transition2 = transition,\n    when = _transition2.when;\n  if (when) {\n    var _ref2 = when === \"beforeChildren\" ? [getAnimation, getChildAnimations] : [getChildAnimations, getAnimation],\n      _ref3 = _slicedToArray(_ref2, 2),\n      first = _ref3[0],\n      last = _ref3[1];\n    return first().then(last);\n  } else {\n    return Promise.all([getAnimation(), getChildAnimations(options.delay)]);\n  }\n}\n/**\n * @internal\n */\nfunction animateTarget(visualElement, definition) {\n  var _ref4 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n    _ref4$delay = _ref4.delay,\n    delay = _ref4$delay === void 0 ? 0 : _ref4$delay,\n    transitionOverride = _ref4.transitionOverride,\n    type = _ref4.type;\n  var _a;\n  var _visualElement$makeTa = visualElement.makeTargetAnimatable(definition),\n    _visualElement$makeTa2 = _visualElement$makeTa.transition,\n    transition = _visualElement$makeTa2 === void 0 ? visualElement.getDefaultTransition() : _visualElement$makeTa2,\n    transitionEnd = _visualElement$makeTa.transitionEnd,\n    target = _objectWithoutProperties(_visualElement$makeTa, _excluded);\n  var willChange = visualElement.getValue(\"willChange\");\n  if (transitionOverride) transition = transitionOverride;\n  var animations = [];\n  var animationTypeState = type && ((_a = visualElement.animationState) === null || _a === void 0 ? void 0 : _a.getState()[type]);\n  var _loop = function _loop(key) {\n    var value = visualElement.getValue(key);\n    var valueTarget = target[key];\n    if (!value || valueTarget === undefined || animationTypeState && shouldBlockAnimation(animationTypeState, key)) {\n      return \"continue\";\n    }\n    var valueTransition = _objectSpread({\n      delay: delay,\n      elapsed: 0\n    }, transition);\n    /**\n     * If this is the first time a value is being animated, check\n     * to see if we're handling off from an existing animation.\n     */\n    if (window.HandoffAppearAnimations && !value.hasAnimated) {\n      var appearId = visualElement.getProps()[optimizedAppearDataAttribute];\n      if (appearId) {\n        valueTransition.elapsed = window.HandoffAppearAnimations(appearId, key, value, sync);\n      }\n    }\n    var animation = value.start(createMotionValueAnimation(key, value, valueTarget, visualElement.shouldReduceMotion && transformProps.has(key) ? {\n      type: false\n    } : valueTransition));\n    if (isWillChangeMotionValue(willChange)) {\n      willChange.add(key);\n      animation = animation.then(function () {\n        return willChange.remove(key);\n      });\n    }\n    animations.push(animation);\n  };\n  for (var key in target) {\n    var _ret = _loop(key);\n    if (_ret === \"continue\") continue;\n  }\n  return Promise.all(animations).then(function () {\n    transitionEnd && setTarget(visualElement, transitionEnd);\n  });\n}\nfunction animateChildren(visualElement, variant) {\n  var delayChildren = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  var staggerChildren = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n  var staggerDirection = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1;\n  var options = arguments.length > 5 ? arguments[5] : undefined;\n  var animations = [];\n  var maxStaggerDuration = (visualElement.variantChildren.size - 1) * staggerChildren;\n  var generateStaggerDuration = staggerDirection === 1 ? function () {\n    var i = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    return i * staggerChildren;\n  } : function () {\n    var i = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    return maxStaggerDuration - i * staggerChildren;\n  };\n  Array.from(visualElement.variantChildren).sort(sortByTreeOrder).forEach(function (child, i) {\n    child.notify(\"AnimationStart\", variant);\n    animations.push(animateVariant(child, variant, _objectSpread(_objectSpread({}, options), {}, {\n      delay: delayChildren + generateStaggerDuration(i)\n    })).then(function () {\n      return child.notify(\"AnimationComplete\", variant);\n    }));\n  });\n  return Promise.all(animations);\n}\nfunction stopAnimation(visualElement) {\n  visualElement.values.forEach(function (value) {\n    return value.stop();\n  });\n}\nfunction sortByTreeOrder(a, b) {\n  return a.sortNodePosition(b);\n}\n/**\n * Decide whether we should block this animation. Previously, we achieved this\n * just by checking whether the key was listed in protectedKeys, but this\n * posed problems if an animation was triggered by afterChildren and protectedKeys\n * had been set to true in the meantime.\n */\nfunction shouldBlockAnimation(_ref5, key) {\n  var protectedKeys = _ref5.protectedKeys,\n    needsAnimating = _ref5.needsAnimating;\n  var shouldBlock = protectedKeys.hasOwnProperty(key) && needsAnimating[key] !== true;\n  needsAnimating[key] = false;\n  return shouldBlock;\n}\nexport { animateVisualElement, sortByTreeOrder, stopAnimation };","map":{"version":3,"names":["setTarget","resolveVariant","transformProps","isWillChangeMotionValue","optimizedAppearDataAttribute","createMotionValueAnimation","sync","animateVisualElement","visualElement","definition","options","arguments","length","undefined","notify","animation","Array","isArray","animations","map","variant","animateVariant","Promise","all","resolvedDefinition","custom","animateTarget","then","_a","resolved","_ref","_ref$transition","transition","getDefaultTransition","transitionOverride","getAnimation","resolve","getChildAnimations","variantChildren","size","forwardDelay","_transition","_transition$delayChil","delayChildren","staggerChildren","staggerDirection","animateChildren","_transition2","when","_ref2","_ref3","_slicedToArray","first","last","delay","_ref4","_ref4$delay","type","_visualElement$makeTa","makeTargetAnimatable","_visualElement$makeTa2","transitionEnd","target","_objectWithoutProperties","_excluded","willChange","getValue","animationTypeState","animationState","getState","_loop","key","value","valueTarget","shouldBlockAnimation","valueTransition","_objectSpread","elapsed","window","HandoffAppearAnimations","hasAnimated","appearId","getProps","start","shouldReduceMotion","has","add","remove","push","_ret","maxStaggerDuration","generateStaggerDuration","i","from","sort","sortByTreeOrder","forEach","child","stopAnimation","values","stop","a","b","sortNodePosition","_ref5","protectedKeys","needsAnimating","shouldBlock","hasOwnProperty"],"sources":["C:/Users/ferre/OneDrive/Escritorio/portfolio-react/node_modules/framer-motion/dist/es/render/utils/animation.mjs"],"sourcesContent":["import { setTarget } from './setters.mjs';\nimport { resolveVariant } from './resolve-dynamic-variants.mjs';\nimport { transformProps } from '../html/utils/transform.mjs';\nimport { isWillChangeMotionValue } from '../../value/use-will-change/is.mjs';\nimport { optimizedAppearDataAttribute } from '../../animation/optimized-appear/data-id.mjs';\nimport { createMotionValueAnimation } from '../../animation/index.mjs';\nimport { sync } from '../../frameloop/index.mjs';\n\nfunction animateVisualElement(visualElement, definition, options = {}) {\n    visualElement.notify(\"AnimationStart\", definition);\n    let animation;\n    if (Array.isArray(definition)) {\n        const animations = definition.map((variant) => animateVariant(visualElement, variant, options));\n        animation = Promise.all(animations);\n    }\n    else if (typeof definition === \"string\") {\n        animation = animateVariant(visualElement, definition, options);\n    }\n    else {\n        const resolvedDefinition = typeof definition === \"function\"\n            ? resolveVariant(visualElement, definition, options.custom)\n            : definition;\n        animation = animateTarget(visualElement, resolvedDefinition, options);\n    }\n    return animation.then(() => visualElement.notify(\"AnimationComplete\", definition));\n}\nfunction animateVariant(visualElement, variant, options = {}) {\n    var _a;\n    const resolved = resolveVariant(visualElement, variant, options.custom);\n    let { transition = visualElement.getDefaultTransition() || {} } = resolved || {};\n    if (options.transitionOverride) {\n        transition = options.transitionOverride;\n    }\n    /**\n     * If we have a variant, create a callback that runs it as an animation.\n     * Otherwise, we resolve a Promise immediately for a composable no-op.\n     */\n    const getAnimation = resolved\n        ? () => animateTarget(visualElement, resolved, options)\n        : () => Promise.resolve();\n    /**\n     * If we have children, create a callback that runs all their animations.\n     * Otherwise, we resolve a Promise immediately for a composable no-op.\n     */\n    const getChildAnimations = ((_a = visualElement.variantChildren) === null || _a === void 0 ? void 0 : _a.size)\n        ? (forwardDelay = 0) => {\n            const { delayChildren = 0, staggerChildren, staggerDirection, } = transition;\n            return animateChildren(visualElement, variant, delayChildren + forwardDelay, staggerChildren, staggerDirection, options);\n        }\n        : () => Promise.resolve();\n    /**\n     * If the transition explicitly defines a \"when\" option, we need to resolve either\n     * this animation or all children animations before playing the other.\n     */\n    const { when } = transition;\n    if (when) {\n        const [first, last] = when === \"beforeChildren\"\n            ? [getAnimation, getChildAnimations]\n            : [getChildAnimations, getAnimation];\n        return first().then(last);\n    }\n    else {\n        return Promise.all([getAnimation(), getChildAnimations(options.delay)]);\n    }\n}\n/**\n * @internal\n */\nfunction animateTarget(visualElement, definition, { delay = 0, transitionOverride, type } = {}) {\n    var _a;\n    let { transition = visualElement.getDefaultTransition(), transitionEnd, ...target } = visualElement.makeTargetAnimatable(definition);\n    const willChange = visualElement.getValue(\"willChange\");\n    if (transitionOverride)\n        transition = transitionOverride;\n    const animations = [];\n    const animationTypeState = type && ((_a = visualElement.animationState) === null || _a === void 0 ? void 0 : _a.getState()[type]);\n    for (const key in target) {\n        const value = visualElement.getValue(key);\n        const valueTarget = target[key];\n        if (!value ||\n            valueTarget === undefined ||\n            (animationTypeState &&\n                shouldBlockAnimation(animationTypeState, key))) {\n            continue;\n        }\n        const valueTransition = { delay, elapsed: 0, ...transition };\n        /**\n         * If this is the first time a value is being animated, check\n         * to see if we're handling off from an existing animation.\n         */\n        if (window.HandoffAppearAnimations && !value.hasAnimated) {\n            const appearId = visualElement.getProps()[optimizedAppearDataAttribute];\n            if (appearId) {\n                valueTransition.elapsed = window.HandoffAppearAnimations(appearId, key, value, sync);\n            }\n        }\n        let animation = value.start(createMotionValueAnimation(key, value, valueTarget, visualElement.shouldReduceMotion && transformProps.has(key)\n            ? { type: false }\n            : valueTransition));\n        if (isWillChangeMotionValue(willChange)) {\n            willChange.add(key);\n            animation = animation.then(() => willChange.remove(key));\n        }\n        animations.push(animation);\n    }\n    return Promise.all(animations).then(() => {\n        transitionEnd && setTarget(visualElement, transitionEnd);\n    });\n}\nfunction animateChildren(visualElement, variant, delayChildren = 0, staggerChildren = 0, staggerDirection = 1, options) {\n    const animations = [];\n    const maxStaggerDuration = (visualElement.variantChildren.size - 1) * staggerChildren;\n    const generateStaggerDuration = staggerDirection === 1\n        ? (i = 0) => i * staggerChildren\n        : (i = 0) => maxStaggerDuration - i * staggerChildren;\n    Array.from(visualElement.variantChildren)\n        .sort(sortByTreeOrder)\n        .forEach((child, i) => {\n        child.notify(\"AnimationStart\", variant);\n        animations.push(animateVariant(child, variant, {\n            ...options,\n            delay: delayChildren + generateStaggerDuration(i),\n        }).then(() => child.notify(\"AnimationComplete\", variant)));\n    });\n    return Promise.all(animations);\n}\nfunction stopAnimation(visualElement) {\n    visualElement.values.forEach((value) => value.stop());\n}\nfunction sortByTreeOrder(a, b) {\n    return a.sortNodePosition(b);\n}\n/**\n * Decide whether we should block this animation. Previously, we achieved this\n * just by checking whether the key was listed in protectedKeys, but this\n * posed problems if an animation was triggered by afterChildren and protectedKeys\n * had been set to true in the meantime.\n */\nfunction shouldBlockAnimation({ protectedKeys, needsAnimating }, key) {\n    const shouldBlock = protectedKeys.hasOwnProperty(key) && needsAnimating[key] !== true;\n    needsAnimating[key] = false;\n    return shouldBlock;\n}\n\nexport { animateVisualElement, sortByTreeOrder, stopAnimation };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}