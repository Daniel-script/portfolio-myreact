{"ast":null,"code":"import { useRef, useEffect } from 'react';\nimport { AnimationType } from '../../../render/utils/types.mjs';\nimport { warnOnce } from '../../../utils/warn-once.mjs';\nimport { observeIntersection } from './observers.mjs';\nfunction useViewport(_ref) {\n  var visualElement = _ref.visualElement,\n    whileInView = _ref.whileInView,\n    onViewportEnter = _ref.onViewportEnter,\n    onViewportLeave = _ref.onViewportLeave,\n    _ref$viewport = _ref.viewport,\n    viewport = _ref$viewport === void 0 ? {} : _ref$viewport;\n  var state = useRef({\n    hasEnteredView: false,\n    isInView: false\n  });\n  var shouldObserve = Boolean(whileInView || onViewportEnter || onViewportLeave);\n  if (viewport.once && state.current.hasEnteredView) shouldObserve = false;\n  var useObserver = typeof IntersectionObserver === \"undefined\" ? useMissingIntersectionObserver : useIntersectionObserver;\n  useObserver(shouldObserve, state.current, visualElement, viewport);\n}\nvar thresholdNames = {\n  some: 0,\n  all: 1\n};\nfunction useIntersectionObserver(shouldObserve, state, visualElement, _ref2) {\n  var root = _ref2.root,\n    rootMargin = _ref2.margin,\n    _ref2$amount = _ref2.amount,\n    amount = _ref2$amount === void 0 ? \"some\" : _ref2$amount,\n    once = _ref2.once;\n  useEffect(function () {\n    if (!shouldObserve || !visualElement.current) return;\n    var options = {\n      root: root === null || root === void 0 ? void 0 : root.current,\n      rootMargin: rootMargin,\n      threshold: typeof amount === \"number\" ? amount : thresholdNames[amount]\n    };\n    var intersectionCallback = function intersectionCallback(entry) {\n      var isIntersecting = entry.isIntersecting;\n      /**\n       * If there's been no change in the viewport state, early return.\n       */\n      if (state.isInView === isIntersecting) return;\n      state.isInView = isIntersecting;\n      /**\n       * Handle hasEnteredView. If this is only meant to run once, and\n       * element isn't visible, early return. Otherwise set hasEnteredView to true.\n       */\n      if (once && !isIntersecting && state.hasEnteredView) {\n        return;\n      } else if (isIntersecting) {\n        state.hasEnteredView = true;\n      }\n      if (visualElement.animationState) {\n        visualElement.animationState.setActive(AnimationType.InView, isIntersecting);\n      }\n      /**\n       * Use the latest committed props rather than the ones in scope\n       * when this observer is created\n       */\n      var props = visualElement.getProps();\n      var callback = isIntersecting ? props.onViewportEnter : props.onViewportLeave;\n      callback && callback(entry);\n    };\n    return observeIntersection(visualElement.current, options, intersectionCallback);\n  }, [shouldObserve, root, rootMargin, amount]);\n}\n/**\n * If IntersectionObserver is missing, we activate inView and fire onViewportEnter\n * on mount. This way, the page will be in the state the author expects users\n * to see it in for everyone.\n */\nfunction useMissingIntersectionObserver(shouldObserve, state, visualElement, _ref3) {\n  var _ref3$fallback = _ref3.fallback,\n    fallback = _ref3$fallback === void 0 ? true : _ref3$fallback;\n  useEffect(function () {\n    if (!shouldObserve || !fallback) return;\n    if (process.env.NODE_ENV !== \"production\") {\n      warnOnce(false, \"IntersectionObserver not available on this device. whileInView animations will trigger on mount.\");\n    }\n    /**\n     * Fire this in an rAF because, at this point, the animation state\n     * won't have flushed for the first time and there's certain logic in\n     * there that behaves differently on the initial animation.\n     *\n     * This hook should be quite rarely called so setting this in an rAF\n     * is preferred to changing the behaviour of the animation state.\n     */\n    requestAnimationFrame(function () {\n      state.hasEnteredView = true;\n      var _visualElement$getPro = visualElement.getProps(),\n        onViewportEnter = _visualElement$getPro.onViewportEnter;\n      onViewportEnter && onViewportEnter(null);\n      if (visualElement.animationState) {\n        visualElement.animationState.setActive(AnimationType.InView, true);\n      }\n    });\n  }, [shouldObserve]);\n}\nexport { useViewport };","map":{"version":3,"names":["useRef","useEffect","AnimationType","warnOnce","observeIntersection","useViewport","_ref","visualElement","whileInView","onViewportEnter","onViewportLeave","_ref$viewport","viewport","state","hasEnteredView","isInView","shouldObserve","Boolean","once","current","useObserver","IntersectionObserver","useMissingIntersectionObserver","useIntersectionObserver","thresholdNames","some","all","_ref2","root","rootMargin","margin","_ref2$amount","amount","options","threshold","intersectionCallback","entry","isIntersecting","animationState","setActive","InView","props","getProps","callback","_ref3","_ref3$fallback","fallback","process","env","NODE_ENV","requestAnimationFrame","_visualElement$getPro"],"sources":["C:/Users/ferre/OneDrive/Escritorio/portfolio-react/node_modules/framer-motion/dist/es/motion/features/viewport/use-viewport.mjs"],"sourcesContent":["import { useRef, useEffect } from 'react';\nimport { AnimationType } from '../../../render/utils/types.mjs';\nimport { warnOnce } from '../../../utils/warn-once.mjs';\nimport { observeIntersection } from './observers.mjs';\n\nfunction useViewport({ visualElement, whileInView, onViewportEnter, onViewportLeave, viewport = {}, }) {\n    const state = useRef({\n        hasEnteredView: false,\n        isInView: false,\n    });\n    let shouldObserve = Boolean(whileInView || onViewportEnter || onViewportLeave);\n    if (viewport.once && state.current.hasEnteredView)\n        shouldObserve = false;\n    const useObserver = typeof IntersectionObserver === \"undefined\"\n        ? useMissingIntersectionObserver\n        : useIntersectionObserver;\n    useObserver(shouldObserve, state.current, visualElement, viewport);\n}\nconst thresholdNames = {\n    some: 0,\n    all: 1,\n};\nfunction useIntersectionObserver(shouldObserve, state, visualElement, { root, margin: rootMargin, amount = \"some\", once }) {\n    useEffect(() => {\n        if (!shouldObserve || !visualElement.current)\n            return;\n        const options = {\n            root: root === null || root === void 0 ? void 0 : root.current,\n            rootMargin,\n            threshold: typeof amount === \"number\" ? amount : thresholdNames[amount],\n        };\n        const intersectionCallback = (entry) => {\n            const { isIntersecting } = entry;\n            /**\n             * If there's been no change in the viewport state, early return.\n             */\n            if (state.isInView === isIntersecting)\n                return;\n            state.isInView = isIntersecting;\n            /**\n             * Handle hasEnteredView. If this is only meant to run once, and\n             * element isn't visible, early return. Otherwise set hasEnteredView to true.\n             */\n            if (once && !isIntersecting && state.hasEnteredView) {\n                return;\n            }\n            else if (isIntersecting) {\n                state.hasEnteredView = true;\n            }\n            if (visualElement.animationState) {\n                visualElement.animationState.setActive(AnimationType.InView, isIntersecting);\n            }\n            /**\n             * Use the latest committed props rather than the ones in scope\n             * when this observer is created\n             */\n            const props = visualElement.getProps();\n            const callback = isIntersecting\n                ? props.onViewportEnter\n                : props.onViewportLeave;\n            callback && callback(entry);\n        };\n        return observeIntersection(visualElement.current, options, intersectionCallback);\n    }, [shouldObserve, root, rootMargin, amount]);\n}\n/**\n * If IntersectionObserver is missing, we activate inView and fire onViewportEnter\n * on mount. This way, the page will be in the state the author expects users\n * to see it in for everyone.\n */\nfunction useMissingIntersectionObserver(shouldObserve, state, visualElement, { fallback = true }) {\n    useEffect(() => {\n        if (!shouldObserve || !fallback)\n            return;\n        if (process.env.NODE_ENV !== \"production\") {\n            warnOnce(false, \"IntersectionObserver not available on this device. whileInView animations will trigger on mount.\");\n        }\n        /**\n         * Fire this in an rAF because, at this point, the animation state\n         * won't have flushed for the first time and there's certain logic in\n         * there that behaves differently on the initial animation.\n         *\n         * This hook should be quite rarely called so setting this in an rAF\n         * is preferred to changing the behaviour of the animation state.\n         */\n        requestAnimationFrame(() => {\n            state.hasEnteredView = true;\n            const { onViewportEnter } = visualElement.getProps();\n            onViewportEnter && onViewportEnter(null);\n            if (visualElement.animationState) {\n                visualElement.animationState.setActive(AnimationType.InView, true);\n            }\n        });\n    }, [shouldObserve]);\n}\n\nexport { useViewport };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}